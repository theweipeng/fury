// Code generated by forygen. DO NOT EDIT.
// source: /Users/chaokunyang/Desktop/dev/fory2/go/fory/tests/structs.go
// generated at: 2025-12-19T17:28:53+08:00

package fory

import (
	"fmt"
	"github.com/apache/fory/go/fory"
	"reflect"
)

func init() {
	fory.RegisterSerializerFactory((*DynamicSliceDemo)(nil), NewSerializerFor_DynamicSliceDemo)
	fory.RegisterSerializerFactory((*MapDemo)(nil), NewSerializerFor_MapDemo)
	fory.RegisterSerializerFactory((*SliceDemo)(nil), NewSerializerFor_SliceDemo)
	fory.RegisterSerializerFactory((*ValidationDemo)(nil), NewSerializerFor_ValidationDemo)
}

type DynamicSliceDemo_ForyGenSerializer struct{}

func NewSerializerFor_DynamicSliceDemo() fory.Serializer {
	return DynamicSliceDemo_ForyGenSerializer{}
}

// Write is the entry point for serialization with ref/type handling
func (g DynamicSliceDemo_ForyGenSerializer) Write(ctx *fory.WriteContext, refMode fory.RefMode, writeType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		refWritten, err := ctx.RefResolver().WriteRefOrNull(ctx.Buffer(), value)
		if err != nil {
			return err
		}
		if refWritten {
			return nil
		}
	case fory.RefModeNullOnly:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		ctx.Buffer().WriteInt8(-1) // NotNullValueFlag
	}
	if writeType {
		ctx.Buffer().WriteVaruint32(uint32(fory.NAMED_STRUCT))
	}
	return g.WriteData(ctx, value)
}

// WriteTyped provides strongly-typed serialization with no reflection overhead
func (g DynamicSliceDemo_ForyGenSerializer) WriteTyped(ctx *fory.WriteContext, v *DynamicSliceDemo) error {
	buf := ctx.Buffer()
	// WriteData precomputed struct hash for compatibility checking
	buf.WriteInt32(659991945) // hash of DynamicSliceDemo structure

	// WriteData fields in sorted order
	// Field: DynamicSlice ([]interface{})
	// Dynamic slice []interface{} handling - manual serialization
	if v.DynamicSlice == nil {
		buf.WriteInt8(-3) // null value flag
	} else {
		// WriteData reference flag for the slice itself
		buf.WriteInt8(0) // RefValueFlag
		// WriteData slice length
		buf.WriteVaruint32(uint32(len(v.DynamicSlice)))
		// WriteData collection flags for dynamic slice []interface{}
		// Only CollectionTrackingRef is set (no declared type, may have different types)
		buf.WriteInt8(1) // CollectionTrackingRef only
		// WriteData each element using WriteValue
		for _, elem := range v.DynamicSlice {
			ctx.WriteValue(reflect.ValueOf(elem))
		}
	}
	return nil
}

// WriteData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g DynamicSliceDemo_ForyGenSerializer) WriteData(ctx *fory.WriteContext, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *DynamicSliceDemo
	if value.Kind() == reflect.Ptr {
		v = value.Interface().(*DynamicSliceDemo)
	} else {
		// Create a copy to get a pointer
		temp := value.Interface().(DynamicSliceDemo)
		v = &temp
	}
	// Delegate to strongly-typed method for maximum performance
	return g.WriteTyped(ctx, v)
}

// Read is the entry point for deserialization with ref/type handling
func (g DynamicSliceDemo_ForyGenSerializer) Read(ctx *fory.ReadContext, refMode fory.RefMode, readType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		refID, err := ctx.RefResolver().TryPreserveRefId(ctx.Buffer())
		if err != nil {
			return err
		}
		if int8(refID) < -1 { // NotNullValueFlag
			obj := ctx.RefResolver().GetReadObject(refID)
			if obj.IsValid() {
				value.Set(obj)
			}
			return nil
		}
	case fory.RefModeNullOnly:
		flag := ctx.Buffer().ReadInt8()
		if flag == -3 { // NullFlag
			return nil
		}
	}
	if readType {
		if _, err := ctx.TypeResolver().ReadTypeInfo(ctx.Buffer(), value); err != nil {
			return err
		}
	}
	return g.ReadData(ctx, value.Type(), value)
}

// ReadTyped provides strongly-typed deserialization with no reflection overhead
func (g DynamicSliceDemo_ForyGenSerializer) ReadTyped(ctx *fory.ReadContext, v *DynamicSliceDemo) error {
	buf := ctx.Buffer()
	// ReadData and verify struct hash
	if got := buf.ReadInt32(); got != 659991945 {
		return fmt.Errorf("struct hash mismatch for DynamicSliceDemo: expected 659991945, got %d", got)
	}

	// ReadData fields in same order as write
	// Field: DynamicSlice ([]interface{})
	// Dynamic slice []interface{} handling - manual deserialization
	if flag := buf.ReadInt8(); flag == -3 {
		v.DynamicSlice = nil // null slice
	} else if flag == 0 {
		// ReadData slice length
		sliceLen := buf.ReadVaruint32()
		// ReadData collection flags (ignore for now)
		_ = buf.ReadInt8()
		// Create slice with proper capacity
		v.DynamicSlice = make([]interface{}, sliceLen)
		// ReadData each element using ReadValue
		for i := range v.DynamicSlice {
			ctx.ReadValue(reflect.ValueOf(&v.DynamicSlice[i]).Elem())
		}
	} else {
		return fmt.Errorf("expected RefValueFlag or NullFlag for dynamic slice field DynamicSlice, got %d", flag)
	}
	return nil
}

// ReadData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g DynamicSliceDemo_ForyGenSerializer) ReadData(ctx *fory.ReadContext, type_ reflect.Type, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *DynamicSliceDemo
	if value.Kind() == reflect.Ptr {
		if value.IsNil() {
			// For pointer types, allocate using type_.Elem()
			value.Set(reflect.New(type_.Elem()))
		}
		v = value.Interface().(*DynamicSliceDemo)
	} else {
		// value must be addressable for read
		v = value.Addr().Interface().(*DynamicSliceDemo)
	}
	// Delegate to strongly-typed method for maximum performance
	return g.ReadTyped(ctx, v)
}

// ReadWithTypeInfo deserializes with pre-read type information
func (g DynamicSliceDemo_ForyGenSerializer) ReadWithTypeInfo(ctx *fory.ReadContext, refMode fory.RefMode, typeInfo *fory.TypeInfo, value reflect.Value) error {
	return g.Read(ctx, refMode, false, value)
}

type MapDemo_ForyGenSerializer struct{}

func NewSerializerFor_MapDemo() fory.Serializer {
	return MapDemo_ForyGenSerializer{}
}

// Write is the entry point for serialization with ref/type handling
func (g MapDemo_ForyGenSerializer) Write(ctx *fory.WriteContext, refMode fory.RefMode, writeType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		refWritten, err := ctx.RefResolver().WriteRefOrNull(ctx.Buffer(), value)
		if err != nil {
			return err
		}
		if refWritten {
			return nil
		}
	case fory.RefModeNullOnly:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		ctx.Buffer().WriteInt8(-1) // NotNullValueFlag
	}
	if writeType {
		ctx.Buffer().WriteVaruint32(uint32(fory.NAMED_STRUCT))
	}
	return g.WriteData(ctx, value)
}

// WriteTyped provides strongly-typed serialization with no reflection overhead
func (g MapDemo_ForyGenSerializer) WriteTyped(ctx *fory.WriteContext, v *MapDemo) error {
	buf := ctx.Buffer()
	// WriteData precomputed struct hash for compatibility checking
	buf.WriteInt32(-1565547955) // hash of MapDemo structure

	// WriteData fields in sorted order
	// Field: IntMap (map[int]int)
	buf.WriteInt8(0) // RefValueFlag for map
	{
		mapLen := 0
		if v.IntMap != nil {
			mapLen = len(v.IntMap)
		}
		buf.WriteVaruint32(uint32(mapLen))
		if mapLen > 0 {
			// Calculate KV header flags
			kvHeader := uint8(0)
			isRefTracking := ctx.TrackRef()
			_ = isRefTracking // Mark as used to avoid warning
			chunkSize := 0
			_ = buf.WriterIndex()         // chunkHeaderOffset
			buf.WriteInt8(int8(kvHeader)) // KV header
			chunkSizeOffset := buf.WriterIndex()
			buf.WriteInt8(0) // placeholder for chunk size
			for mapKey, mapValue := range v.IntMap {
				buf.WriteInt64(int64(mapKey))
				buf.WriteInt64(int64(mapValue))
				chunkSize++
				if chunkSize >= 255 {
					// WriteData chunk size and start new chunk
					buf.PutUint8(chunkSizeOffset, uint8(chunkSize))
					if len(v.IntMap) > chunkSize {
						chunkSize = 0
						_ = buf.WriterIndex()         // chunkHeaderOffset
						buf.WriteInt8(int8(kvHeader)) // KV header
						chunkSizeOffset = buf.WriterIndex()
						buf.WriteInt8(0) // placeholder for chunk size
					}
				}
			}
			if chunkSize > 0 {
				buf.PutUint8(chunkSizeOffset, uint8(chunkSize))
			}
		}
	}
	// Field: MixedMap (map[string]int)
	buf.WriteInt8(0) // RefValueFlag for map
	{
		mapLen := 0
		if v.MixedMap != nil {
			mapLen = len(v.MixedMap)
		}
		buf.WriteVaruint32(uint32(mapLen))
		if mapLen > 0 {
			// Calculate KV header flags
			kvHeader := uint8(0)
			isRefTracking := ctx.TrackRef()
			_ = isRefTracking // Mark as used to avoid warning
			if isRefTracking {
				kvHeader |= 0x1 // track key ref
			}
			chunkSize := 0
			_ = buf.WriterIndex()         // chunkHeaderOffset
			buf.WriteInt8(int8(kvHeader)) // KV header
			chunkSizeOffset := buf.WriterIndex()
			buf.WriteInt8(0) // placeholder for chunk size
			for mapKey, mapValue := range v.MixedMap {
				ctx.WriteString(mapKey)
				buf.WriteInt64(int64(mapValue))
				chunkSize++
				if chunkSize >= 255 {
					// WriteData chunk size and start new chunk
					buf.PutUint8(chunkSizeOffset, uint8(chunkSize))
					if len(v.MixedMap) > chunkSize {
						chunkSize = 0
						_ = buf.WriterIndex()         // chunkHeaderOffset
						buf.WriteInt8(int8(kvHeader)) // KV header
						chunkSizeOffset = buf.WriterIndex()
						buf.WriteInt8(0) // placeholder for chunk size
					}
				}
			}
			if chunkSize > 0 {
				buf.PutUint8(chunkSizeOffset, uint8(chunkSize))
			}
		}
	}
	// Field: StringMap (map[string]string)
	buf.WriteInt8(0) // RefValueFlag for map
	{
		mapLen := 0
		if v.StringMap != nil {
			mapLen = len(v.StringMap)
		}
		buf.WriteVaruint32(uint32(mapLen))
		if mapLen > 0 {
			// Calculate KV header flags
			kvHeader := uint8(0)
			isRefTracking := ctx.TrackRef()
			_ = isRefTracking // Mark as used to avoid warning
			if isRefTracking {
				kvHeader |= 0x1 // track key ref
			}
			if isRefTracking {
				kvHeader |= 0x8 // track value ref
			}
			chunkSize := 0
			_ = buf.WriterIndex()         // chunkHeaderOffset
			buf.WriteInt8(int8(kvHeader)) // KV header
			chunkSizeOffset := buf.WriterIndex()
			buf.WriteInt8(0) // placeholder for chunk size
			for mapKey, mapValue := range v.StringMap {
				ctx.WriteString(mapKey)
				ctx.WriteString(mapValue)
				chunkSize++
				if chunkSize >= 255 {
					// WriteData chunk size and start new chunk
					buf.PutUint8(chunkSizeOffset, uint8(chunkSize))
					if len(v.StringMap) > chunkSize {
						chunkSize = 0
						_ = buf.WriterIndex()         // chunkHeaderOffset
						buf.WriteInt8(int8(kvHeader)) // KV header
						chunkSizeOffset = buf.WriterIndex()
						buf.WriteInt8(0) // placeholder for chunk size
					}
				}
			}
			if chunkSize > 0 {
				buf.PutUint8(chunkSizeOffset, uint8(chunkSize))
			}
		}
	}
	return nil
}

// WriteData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g MapDemo_ForyGenSerializer) WriteData(ctx *fory.WriteContext, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *MapDemo
	if value.Kind() == reflect.Ptr {
		v = value.Interface().(*MapDemo)
	} else {
		// Create a copy to get a pointer
		temp := value.Interface().(MapDemo)
		v = &temp
	}
	// Delegate to strongly-typed method for maximum performance
	return g.WriteTyped(ctx, v)
}

// Read is the entry point for deserialization with ref/type handling
func (g MapDemo_ForyGenSerializer) Read(ctx *fory.ReadContext, refMode fory.RefMode, readType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		refID, err := ctx.RefResolver().TryPreserveRefId(ctx.Buffer())
		if err != nil {
			return err
		}
		if int8(refID) < -1 { // NotNullValueFlag
			obj := ctx.RefResolver().GetReadObject(refID)
			if obj.IsValid() {
				value.Set(obj)
			}
			return nil
		}
	case fory.RefModeNullOnly:
		flag := ctx.Buffer().ReadInt8()
		if flag == -3 { // NullFlag
			return nil
		}
	}
	if readType {
		if _, err := ctx.TypeResolver().ReadTypeInfo(ctx.Buffer(), value); err != nil {
			return err
		}
	}
	return g.ReadData(ctx, value.Type(), value)
}

// ReadTyped provides strongly-typed deserialization with no reflection overhead
func (g MapDemo_ForyGenSerializer) ReadTyped(ctx *fory.ReadContext, v *MapDemo) error {
	buf := ctx.Buffer()
	// ReadData and verify struct hash
	if got := buf.ReadInt32(); got != -1565547955 {
		return fmt.Errorf("struct hash mismatch for MapDemo: expected -1565547955, got %d", got)
	}

	// ReadData fields in same order as write
	// Field: IntMap (map[int]int)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for map field, got %d", flag)
	}
	{
		mapLen := int(buf.ReadVaruint32())
		if mapLen == 0 {
			v.IntMap = make(map[int]int)
		} else {
			v.IntMap = make(map[int]int, mapLen)
			mapSize := mapLen
			for mapSize > 0 {
				// ReadData KV header
				kvHeader := buf.ReadUint8()
				chunkSize := int(buf.ReadUint8())
				trackKeyRef := (kvHeader & 0x1) != 0
				keyNotDeclared := (kvHeader & 0x4) != 0
				trackValueRef := (kvHeader & 0x8) != 0
				valueNotDeclared := (kvHeader & 0x20) != 0
				_ = trackKeyRef
				_ = keyNotDeclared
				_ = trackValueRef
				_ = valueNotDeclared
				for i := 0; i < chunkSize; i++ {
					var mapKey int
					mapKey = int(buf.ReadInt64())
					var mapValue int
					mapValue = int(buf.ReadInt64())
					v.IntMap[mapKey] = mapValue
				}
				mapSize -= chunkSize
			}
		}
	}
	// Field: MixedMap (map[string]int)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for map field, got %d", flag)
	}
	{
		mapLen := int(buf.ReadVaruint32())
		if mapLen == 0 {
			v.MixedMap = make(map[string]int)
		} else {
			v.MixedMap = make(map[string]int, mapLen)
			mapSize := mapLen
			for mapSize > 0 {
				// ReadData KV header
				kvHeader := buf.ReadUint8()
				chunkSize := int(buf.ReadUint8())
				trackKeyRef := (kvHeader & 0x1) != 0
				keyNotDeclared := (kvHeader & 0x4) != 0
				trackValueRef := (kvHeader & 0x8) != 0
				valueNotDeclared := (kvHeader & 0x20) != 0
				_ = trackKeyRef
				_ = keyNotDeclared
				_ = trackValueRef
				_ = valueNotDeclared
				for i := 0; i < chunkSize; i++ {
					var mapKey string
					mapKey = ctx.ReadString()
					var mapValue int
					mapValue = int(buf.ReadInt64())
					v.MixedMap[mapKey] = mapValue
				}
				mapSize -= chunkSize
			}
		}
	}
	// Field: StringMap (map[string]string)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for map field, got %d", flag)
	}
	{
		mapLen := int(buf.ReadVaruint32())
		if mapLen == 0 {
			v.StringMap = make(map[string]string)
		} else {
			v.StringMap = make(map[string]string, mapLen)
			mapSize := mapLen
			for mapSize > 0 {
				// ReadData KV header
				kvHeader := buf.ReadUint8()
				chunkSize := int(buf.ReadUint8())
				trackKeyRef := (kvHeader & 0x1) != 0
				keyNotDeclared := (kvHeader & 0x4) != 0
				trackValueRef := (kvHeader & 0x8) != 0
				valueNotDeclared := (kvHeader & 0x20) != 0
				_ = trackKeyRef
				_ = keyNotDeclared
				_ = trackValueRef
				_ = valueNotDeclared
				for i := 0; i < chunkSize; i++ {
					var mapKey string
					mapKey = ctx.ReadString()
					var mapValue string
					mapValue = ctx.ReadString()
					v.StringMap[mapKey] = mapValue
				}
				mapSize -= chunkSize
			}
		}
	}
	return nil
}

// ReadData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g MapDemo_ForyGenSerializer) ReadData(ctx *fory.ReadContext, type_ reflect.Type, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *MapDemo
	if value.Kind() == reflect.Ptr {
		if value.IsNil() {
			// For pointer types, allocate using type_.Elem()
			value.Set(reflect.New(type_.Elem()))
		}
		v = value.Interface().(*MapDemo)
	} else {
		// value must be addressable for read
		v = value.Addr().Interface().(*MapDemo)
	}
	// Delegate to strongly-typed method for maximum performance
	return g.ReadTyped(ctx, v)
}

// ReadWithTypeInfo deserializes with pre-read type information
func (g MapDemo_ForyGenSerializer) ReadWithTypeInfo(ctx *fory.ReadContext, refMode fory.RefMode, typeInfo *fory.TypeInfo, value reflect.Value) error {
	return g.Read(ctx, refMode, false, value)
}

type SliceDemo_ForyGenSerializer struct{}

func NewSerializerFor_SliceDemo() fory.Serializer {
	return SliceDemo_ForyGenSerializer{}
}

// Write is the entry point for serialization with ref/type handling
func (g SliceDemo_ForyGenSerializer) Write(ctx *fory.WriteContext, refMode fory.RefMode, writeType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		refWritten, err := ctx.RefResolver().WriteRefOrNull(ctx.Buffer(), value)
		if err != nil {
			return err
		}
		if refWritten {
			return nil
		}
	case fory.RefModeNullOnly:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		ctx.Buffer().WriteInt8(-1) // NotNullValueFlag
	}
	if writeType {
		ctx.Buffer().WriteVaruint32(uint32(fory.NAMED_STRUCT))
	}
	return g.WriteData(ctx, value)
}

// WriteTyped provides strongly-typed serialization with no reflection overhead
func (g SliceDemo_ForyGenSerializer) WriteTyped(ctx *fory.WriteContext, v *SliceDemo) error {
	buf := ctx.Buffer()
	// WriteData precomputed struct hash for compatibility checking
	buf.WriteInt32(-1393614469) // hash of SliceDemo structure

	// WriteData fields in sorted order
	// Field: BoolSlice ([]bool)
	buf.WriteInt8(0) // RefValueFlag for slice
	{
		sliceLen := 0
		if v.BoolSlice != nil {
			sliceLen = len(v.BoolSlice)
		}
		buf.WriteVaruint32(uint32(sliceLen))
		if sliceLen > 0 {
			collectFlag := 12 // CollectionIsSameType | CollectionIsDeclElementType
			buf.WriteInt8(int8(collectFlag))
			for _, elem := range v.BoolSlice {
				buf.WriteBool(elem)
			}
		}
	}
	// Field: FloatSlice ([]float64)
	buf.WriteInt8(0) // RefValueFlag for slice
	{
		sliceLen := 0
		if v.FloatSlice != nil {
			sliceLen = len(v.FloatSlice)
		}
		buf.WriteVaruint32(uint32(sliceLen))
		if sliceLen > 0 {
			collectFlag := 12 // CollectionIsSameType | CollectionIsDeclElementType
			buf.WriteInt8(int8(collectFlag))
			for _, elem := range v.FloatSlice {
				buf.WriteFloat64(elem)
			}
		}
	}
	// Field: IntSlice ([]int32)
	buf.WriteInt8(0) // RefValueFlag for slice
	{
		sliceLen := 0
		if v.IntSlice != nil {
			sliceLen = len(v.IntSlice)
		}
		buf.WriteVaruint32(uint32(sliceLen))
		if sliceLen > 0 {
			collectFlag := 12 // CollectionIsSameType | CollectionIsDeclElementType
			buf.WriteInt8(int8(collectFlag))
			for _, elem := range v.IntSlice {
				buf.WriteVarint32(elem)
			}
		}
	}
	// Field: StringSlice ([]string)
	buf.WriteInt8(0) // RefValueFlag for slice
	{
		sliceLen := 0
		if v.StringSlice != nil {
			sliceLen = len(v.StringSlice)
		}
		buf.WriteVaruint32(uint32(sliceLen))
		if sliceLen > 0 {
			collectFlag := 12 // CollectionIsSameType | CollectionIsDeclElementType
			if ctx.TrackRef() {
				collectFlag |= 1 // CollectionTrackingRef for referencable element type
			}
			buf.WriteInt8(int8(collectFlag))
			for _, elem := range v.StringSlice {
				if ctx.TrackRef() {
					buf.WriteInt8(-1) // NotNullValueFlag for element
				}
				ctx.WriteString(elem)
			}
		}
	}
	return nil
}

// WriteData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g SliceDemo_ForyGenSerializer) WriteData(ctx *fory.WriteContext, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *SliceDemo
	if value.Kind() == reflect.Ptr {
		v = value.Interface().(*SliceDemo)
	} else {
		// Create a copy to get a pointer
		temp := value.Interface().(SliceDemo)
		v = &temp
	}
	// Delegate to strongly-typed method for maximum performance
	return g.WriteTyped(ctx, v)
}

// Read is the entry point for deserialization with ref/type handling
func (g SliceDemo_ForyGenSerializer) Read(ctx *fory.ReadContext, refMode fory.RefMode, readType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		refID, err := ctx.RefResolver().TryPreserveRefId(ctx.Buffer())
		if err != nil {
			return err
		}
		if int8(refID) < -1 { // NotNullValueFlag
			obj := ctx.RefResolver().GetReadObject(refID)
			if obj.IsValid() {
				value.Set(obj)
			}
			return nil
		}
	case fory.RefModeNullOnly:
		flag := ctx.Buffer().ReadInt8()
		if flag == -3 { // NullFlag
			return nil
		}
	}
	if readType {
		if _, err := ctx.TypeResolver().ReadTypeInfo(ctx.Buffer(), value); err != nil {
			return err
		}
	}
	return g.ReadData(ctx, value.Type(), value)
}

// ReadTyped provides strongly-typed deserialization with no reflection overhead
func (g SliceDemo_ForyGenSerializer) ReadTyped(ctx *fory.ReadContext, v *SliceDemo) error {
	buf := ctx.Buffer()
	// ReadData and verify struct hash
	if got := buf.ReadInt32(); got != -1393614469 {
		return fmt.Errorf("struct hash mismatch for SliceDemo: expected -1393614469, got %d", got)
	}

	// ReadData fields in same order as write
	// Field: BoolSlice ([]bool)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for slice field, got %d", flag)
	}
	{
		sliceLen := int(buf.ReadVaruint32())
		if sliceLen == 0 {
			v.BoolSlice = nil
		} else {
			collectFlag := buf.ReadInt8()
			// Check if CollectionIsDeclElementType is set (bit 2, value 4)
			hasDeclType := (collectFlag & 4) != 0
			v.BoolSlice = make([]bool, sliceLen)
			if hasDeclType {
				// Elements are written directly without type IDs
				for i := 0; i < sliceLen; i++ {
					v.BoolSlice[i] = buf.ReadBool()
				}
			} else {
				// Need to read type ID once if CollectionIsSameType is set
				if (collectFlag & 8) != 0 {
					// ReadData element type ID once for all elements
					_ = buf.ReadVaruint32()
				}
				for i := 0; i < sliceLen; i++ {
					v.BoolSlice[i] = buf.ReadBool()
				}
			}
		}
	}
	// Field: FloatSlice ([]float64)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for slice field, got %d", flag)
	}
	{
		sliceLen := int(buf.ReadVaruint32())
		if sliceLen == 0 {
			v.FloatSlice = nil
		} else {
			collectFlag := buf.ReadInt8()
			// Check if CollectionIsDeclElementType is set (bit 2, value 4)
			hasDeclType := (collectFlag & 4) != 0
			v.FloatSlice = make([]float64, sliceLen)
			if hasDeclType {
				// Elements are written directly without type IDs
				for i := 0; i < sliceLen; i++ {
					v.FloatSlice[i] = buf.ReadFloat64()
				}
			} else {
				// Need to read type ID once if CollectionIsSameType is set
				if (collectFlag & 8) != 0 {
					// ReadData element type ID once for all elements
					_ = buf.ReadVaruint32()
				}
				for i := 0; i < sliceLen; i++ {
					v.FloatSlice[i] = buf.ReadFloat64()
				}
			}
		}
	}
	// Field: IntSlice ([]int32)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for slice field, got %d", flag)
	}
	{
		sliceLen := int(buf.ReadVaruint32())
		if sliceLen == 0 {
			v.IntSlice = nil
		} else {
			collectFlag := buf.ReadInt8()
			// Check if CollectionIsDeclElementType is set (bit 2, value 4)
			hasDeclType := (collectFlag & 4) != 0
			v.IntSlice = make([]int32, sliceLen)
			if hasDeclType {
				// Elements are written directly without type IDs
				for i := 0; i < sliceLen; i++ {
					v.IntSlice[i] = buf.ReadVarint32()
				}
			} else {
				// Need to read type ID once if CollectionIsSameType is set
				if (collectFlag & 8) != 0 {
					// ReadData element type ID once for all elements
					_ = buf.ReadVaruint32()
				}
				for i := 0; i < sliceLen; i++ {
					v.IntSlice[i] = buf.ReadVarint32()
				}
			}
		}
	}
	// Field: StringSlice ([]string)
	if flag := buf.ReadInt8(); flag != 0 {
		return fmt.Errorf("expected RefValueFlag for slice field, got %d", flag)
	}
	{
		sliceLen := int(buf.ReadVaruint32())
		if sliceLen == 0 {
			v.StringSlice = nil
		} else {
			collectFlag := buf.ReadInt8()
			// Check if CollectionIsDeclElementType is set (bit 2, value 4)
			hasDeclType := (collectFlag & 4) != 0
			// Check if CollectionTrackingRef is set (bit 0, value 1)
			trackRefs := (collectFlag & 1) != 0
			v.StringSlice = make([]string, sliceLen)
			if hasDeclType {
				// Elements are written directly without type IDs
				for i := 0; i < sliceLen; i++ {
					if trackRefs {
						_ = buf.ReadInt8() // Read ref flag (NotNullValueFlag)
					}
					v.StringSlice[i] = ctx.ReadString()
				}
			} else {
				// Need to read type ID once if CollectionIsSameType is set
				if (collectFlag & 8) != 0 {
					// ReadData element type ID once for all elements
					_ = buf.ReadVaruint32()
				}
				for i := 0; i < sliceLen; i++ {
					if trackRefs {
						_ = buf.ReadInt8() // Read ref flag (NotNullValueFlag)
					}
					v.StringSlice[i] = ctx.ReadString()
				}
			}
		}
	}
	return nil
}

// ReadData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g SliceDemo_ForyGenSerializer) ReadData(ctx *fory.ReadContext, type_ reflect.Type, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *SliceDemo
	if value.Kind() == reflect.Ptr {
		if value.IsNil() {
			// For pointer types, allocate using type_.Elem()
			value.Set(reflect.New(type_.Elem()))
		}
		v = value.Interface().(*SliceDemo)
	} else {
		// value must be addressable for read
		v = value.Addr().Interface().(*SliceDemo)
	}
	// Delegate to strongly-typed method for maximum performance
	return g.ReadTyped(ctx, v)
}

// ReadWithTypeInfo deserializes with pre-read type information
func (g SliceDemo_ForyGenSerializer) ReadWithTypeInfo(ctx *fory.ReadContext, refMode fory.RefMode, typeInfo *fory.TypeInfo, value reflect.Value) error {
	return g.Read(ctx, refMode, false, value)
}

type ValidationDemo_ForyGenSerializer struct{}

func NewSerializerFor_ValidationDemo() fory.Serializer {
	return ValidationDemo_ForyGenSerializer{}
}

// Write is the entry point for serialization with ref/type handling
func (g ValidationDemo_ForyGenSerializer) Write(ctx *fory.WriteContext, refMode fory.RefMode, writeType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		refWritten, err := ctx.RefResolver().WriteRefOrNull(ctx.Buffer(), value)
		if err != nil {
			return err
		}
		if refWritten {
			return nil
		}
	case fory.RefModeNullOnly:
		if !value.IsValid() || (value.Kind() == reflect.Ptr && value.IsNil()) {
			ctx.Buffer().WriteInt8(-3) // NullFlag
			return nil
		}
		ctx.Buffer().WriteInt8(-1) // NotNullValueFlag
	}
	if writeType {
		ctx.Buffer().WriteVaruint32(uint32(fory.NAMED_STRUCT))
	}
	return g.WriteData(ctx, value)
}

// WriteTyped provides strongly-typed serialization with no reflection overhead
func (g ValidationDemo_ForyGenSerializer) WriteTyped(ctx *fory.WriteContext, v *ValidationDemo) error {
	buf := ctx.Buffer()
	// WriteData precomputed struct hash for compatibility checking
	buf.WriteInt32(728169998) // hash of ValidationDemo structure

	// WriteData fields in sorted order
	// Field: D (float64)
	buf.WriteFloat64(v.D)
	// Field: E (bool)
	buf.WriteBool(v.E)
	// Field: C (int64)
	buf.WriteVarint64(v.C)
	// Field: A (int32)
	buf.WriteVarint32(v.A)
	// Field: B (string)
	if ctx.TrackRef() {
		buf.WriteInt8(-1) // NotNullValueFlag for string
	}
	ctx.WriteString(v.B)
	return nil
}

// WriteData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g ValidationDemo_ForyGenSerializer) WriteData(ctx *fory.WriteContext, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *ValidationDemo
	if value.Kind() == reflect.Ptr {
		v = value.Interface().(*ValidationDemo)
	} else {
		// Create a copy to get a pointer
		temp := value.Interface().(ValidationDemo)
		v = &temp
	}
	// Delegate to strongly-typed method for maximum performance
	return g.WriteTyped(ctx, v)
}

// Read is the entry point for deserialization with ref/type handling
func (g ValidationDemo_ForyGenSerializer) Read(ctx *fory.ReadContext, refMode fory.RefMode, readType bool, value reflect.Value) error {
	switch refMode {
	case fory.RefModeTracking:
		refID, err := ctx.RefResolver().TryPreserveRefId(ctx.Buffer())
		if err != nil {
			return err
		}
		if int8(refID) < -1 { // NotNullValueFlag
			obj := ctx.RefResolver().GetReadObject(refID)
			if obj.IsValid() {
				value.Set(obj)
			}
			return nil
		}
	case fory.RefModeNullOnly:
		flag := ctx.Buffer().ReadInt8()
		if flag == -3 { // NullFlag
			return nil
		}
	}
	if readType {
		if _, err := ctx.TypeResolver().ReadTypeInfo(ctx.Buffer(), value); err != nil {
			return err
		}
	}
	return g.ReadData(ctx, value.Type(), value)
}

// ReadTyped provides strongly-typed deserialization with no reflection overhead
func (g ValidationDemo_ForyGenSerializer) ReadTyped(ctx *fory.ReadContext, v *ValidationDemo) error {
	buf := ctx.Buffer()
	// ReadData and verify struct hash
	if got := buf.ReadInt32(); got != 728169998 {
		return fmt.Errorf("struct hash mismatch for ValidationDemo: expected 728169998, got %d", got)
	}

	// ReadData fields in same order as write
	// Field: D (float64)
	v.D = buf.ReadFloat64()
	// Field: E (bool)
	v.E = buf.ReadBool()
	// Field: C (int64)
	v.C = buf.ReadVarint64()
	// Field: A (int32)
	v.A = buf.ReadVarint32()
	// Field: B (string)
	if ctx.TrackRef() {
		_ = buf.ReadInt8() // Read NotNullValueFlag for string
	}
	v.B = ctx.ReadString()
	return nil
}

// ReadData provides reflect.Value interface compatibility (implements fory.Serializer)
func (g ValidationDemo_ForyGenSerializer) ReadData(ctx *fory.ReadContext, type_ reflect.Type, value reflect.Value) error {
	// Convert reflect.Value to concrete type and delegate to typed method
	var v *ValidationDemo
	if value.Kind() == reflect.Ptr {
		if value.IsNil() {
			// For pointer types, allocate using type_.Elem()
			value.Set(reflect.New(type_.Elem()))
		}
		v = value.Interface().(*ValidationDemo)
	} else {
		// value must be addressable for read
		v = value.Addr().Interface().(*ValidationDemo)
	}
	// Delegate to strongly-typed method for maximum performance
	return g.ReadTyped(ctx, v)
}

// ReadWithTypeInfo deserializes with pre-read type information
func (g ValidationDemo_ForyGenSerializer) ReadWithTypeInfo(ctx *fory.ReadContext, refMode fory.RefMode, typeInfo *fory.TypeInfo, value reflect.Value) error {
	return g.Read(ctx, refMode, false, value)
}

// Compile-time guards: These ensure struct definitions haven't changed
// since code generation. If you modify structs, re-run go generate.

// Snapshot of DynamicSliceDemo's underlying type at generation time.
type _DynamicSliceDemo_expected struct {
	DynamicSlice []interface{}
}

// Compile-time check: this conversion is legal only if DynamicSliceDemo's underlying type
// is identical to _DynamicSliceDemo_expected (names, order, types, tags).
//
// If compilation fails here, it means you've modified the DynamicSliceDemo struct but haven't
// regenerated the code. Please run: go generate
//
// If go generate also fails, delete this file first: rm dynamicslicedemo_fory_gen.go
// Then run: go generate
var _ = func(x DynamicSliceDemo) {
	// ERROR: DynamicSliceDemo struct has changed! Run 'go generate' to fix this.
	_ = _DynamicSliceDemo_expected(x)
}

// Snapshot of MapDemo's underlying type at generation time.
type _MapDemo_expected struct {
	StringMap map[string]string
	IntMap    map[int]int
	MixedMap  map[string]int
}

// Compile-time check: this conversion is legal only if MapDemo's underlying type
// is identical to _MapDemo_expected (names, order, types, tags).
//
// If compilation fails here, it means you've modified the MapDemo struct but haven't
// regenerated the code. Please run: go generate
//
// If go generate also fails, delete this file first: rm mapdemo_fory_gen.go
// Then run: go generate
var _ = func(x MapDemo) {
	// ERROR: MapDemo struct has changed! Run 'go generate' to fix this.
	_ = _MapDemo_expected(x)
}

// Snapshot of SliceDemo's underlying type at generation time.
type _SliceDemo_expected struct {
	IntSlice    []int32
	StringSlice []string
	FloatSlice  []float64
	BoolSlice   []bool
}

// Compile-time check: this conversion is legal only if SliceDemo's underlying type
// is identical to _SliceDemo_expected (names, order, types, tags).
//
// If compilation fails here, it means you've modified the SliceDemo struct but haven't
// regenerated the code. Please run: go generate
//
// If go generate also fails, delete this file first: rm slicedemo_fory_gen.go
// Then run: go generate
var _ = func(x SliceDemo) {
	// ERROR: SliceDemo struct has changed! Run 'go generate' to fix this.
	_ = _SliceDemo_expected(x)
}

// Snapshot of ValidationDemo's underlying type at generation time.
type _ValidationDemo_expected struct {
	A int32
	B string
	C int64
	D float64
	E bool
}

// Compile-time check: this conversion is legal only if ValidationDemo's underlying type
// is identical to _ValidationDemo_expected (names, order, types, tags).
//
// If compilation fails here, it means you've modified the ValidationDemo struct but haven't
// regenerated the code. Please run: go generate
//
// If go generate also fails, delete this file first: rm validationdemo_fory_gen.go
// Then run: go generate
var _ = func(x ValidationDemo) {
	// ERROR: ValidationDemo struct has changed! Run 'go generate' to fix this.
	_ = _ValidationDemo_expected(x)
}
